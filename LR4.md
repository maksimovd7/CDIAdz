Дерево — это иерархическая структура данных, где каждый узел связан с единственным родителем и может содержать несколько дочерних узлов. Такое дерево всегда остается связным и не содержит циклов; между любой парой узлов есть ровно один путь.

Граф — это структура, состоящая из набора узлов (вершин) и соединяющих их рёбер (связей). Граф можно представить как пару множеств: одно содержит вершины, другое — рёбра. В графах рёбра бывают направленными (ориентированными) или ненаправленными (неориентированными), а также в графах могут присутствовать циклы.

***

### Как реализовать дерево

- В Python обычно используют классы для узлов, где каждый узел хранит своё значение и ссылки на дочерние элементы. В бинарных деревьях каждый узел содержит две ссылки — на левый и правый потомок, а в произвольных деревьях — список или словарь потомков.  
- В C++ деревья реализуются с помощью структур или классов, где поля узла — это значение и указатели на потомков. Для бинарного дерева — два указателя (`left` и `right`), для общего дерева — динамический массив или список указателей. Память обычно управляется вручную, но можно использовать умные указатели для автоматизации.
- В Java деревья строят через классы, в которых узлы содержат значения и ссылки на дочерние элементы. Для двух потомков — отдельные поля, для произвольного числа — коллекция типа List или массив.

***

### Как реализовать граф

- В Python популярны списки смежности (словарь, где ключ — вершина, значение — список соседей), а также матрица смежности (двумерный список, где каждая строка и столбец — вершины, а значения — наличие рёбер). Для сложных задач используют библиотеки, например, networkx или igraph.
- В C++ используют `std::vector<std::vector>` для списка смежности либо списки через `std::list`, а для плотных графов — матрицу смежности на базе двумерных массивов. Также можно строить граф на уровне узлов и указателей для максимального контроля над структурой.
- В Java реализуют графы через ArrayList для списка смежности или HashMap, если вершины представлены строками или объектами; матрицу смежности — через двумерные массивы.

***

### Алгоритмы поиска (DFS)

- Во всех языках поиска по дереву и графу часто выполняют с помощью обхода в глубину (DFS).  
- В Python обход реализуют рекурсивной функцией, отмечающей посещённые узлы и добавляющей их в путь.
- В C++ и Java DFS строят с помощью рекурсии или стека, где для каждой вершины обходят всех соседей, добавляя их в список посещённых; это работает как для деревьев, так и для графов.
- Временная сложность обхода дерева DFS составляет $$O(N)$$, где $$N$$ — количество узлов; для графа — $$O(V+E)$$, где $$V$$ — число вершин, $$E$$ — число рёбер.


