

### 1) Бинарная куча  

Бинарная куча — это полное двоичное дерево, в котором все уровни, кроме последнего, полностью заполнены, а последний заполняется слева направо. Для неё выполняется основное свойство: каждый родитель либо больше (в max‑heap), либо меньше (в min‑heap) своих потомков.  
В Python бинарная куча реализуется с помощью списка и модуля `heapq`. В этой реализации поддерживается только минимальная куча — родитель всегда меньше или равен дочерним элементам. Чтобы получить максимальную кучу, значения можно инвертировать. Также кучу можно реализовать как отдельный класс. Несмотря на то, что используется список, логически структура работает как дерево. Основные методы: `heappush(list, item)` добавляет элемент с сохранением порядка, а `heappop(list)` удаляет и возвращает минимальный элемент.  
В C++ бинарная куча реализуется как полное двоичное дерево через контейнеры `std::priority_queue` или `std::vector`. Метод `push` добавляет элемент в конец массива, затем при необходимости «поднимает» его, чтобы восстановить свойство кучи; `pop` удаляет элемент с вершины.  
В Java бинарная куча реализуется с помощью класса `PriorityQueue`, который использует внутренний массив и предоставляет API для всех операций. Основные методы: `add()` или `offer()` добавляют элемент, `peek()` возвращает корень без удаления, `poll()` извлекает и удаляет минимальный элемент, после чего происходит перестройка кучи.

***

### 2) Биномиальная куча  

Биномиальная куча — это структура данных для представления очереди с приоритетом, состоящая из набора биномиальных деревьев. В каждом дереве ключ в вершине не меньше ключей её потомков, а деревья различаются по степени.  
В Python, C++ и Java стандартной реализации биномиальной кучи нет, поэтому её создают вручную.  
В Python используется собственный класс `BinomialHeap`, содержащий список корней и узлы. Основные методы: `insert(key)` — создаёт узел и дерево степени 0, `getMin()` — ищет минимальный ключ в списке корней, `merge(heap1, heap2)` — объединяет два множества деревьев.  
В C++ биномиальная куча реализуется вручную как набор биномиальных деревьев с узлами (`BinomialNode`) и методами управления. Основные операции: `insert(int key)`, `getMin()`, `extractMin()`, `merge(BinomialHeap& other)`, `decreaseKey(node, new_key)`. Все они управляют указателями и связями между узлами.  
В Java принципы реализации такие же: структура пишется вручную с помощью классов `BinomialHeap` и `BinomialNode`. Сборщик мусора освобождает память автоматически, а синтаксис методов аналогичен Python и C++.

***

### 3) Куча Фибоначчи  

Куча Фибоначчи — это структура для реализации очереди с приоритетом, построенная на наборе деревьев произвольной формы, удовлетворяющих свойству кучи: значение родителя не больше значений детей. Все деревья объединены в циклический двусвязный список корней, а некоторые операции, например объединение, выполняются отложенно.  
В Python такая куча реализуется вручную через классы `FibonacciNode` и `FibonacciHeap`. Встроенной поддержки нет, а управление памятью происходит автоматически.  
В C++ куча Фибоначчи создаётся на основе структур `Node` и `FibonacciHeap`. Основные методы: `isEmpty()`, `getMin()`, `unite(FibonacciHeap* heap)`, `extractMin()`, `decreaseKey(Element* x, T k)`, `deleteElement(Element* x)`. Ключевая особенность реализации — циклические списки `left` и `right`, что позволяет легко вставлять и удалять узлы.  
В Java аналогично: используются классы `FibonacciNode` и `FibonacciHeap`. Алгоритм вычисления числа Фибоначчи реализуется с помощью функции `fibonacci(long n)`, которая возвращает n‑й элемент последовательности.

***

### 4) Хеш‑таблица  

Хеш‑таблица — это структура данных, хранящая пары «ключ‑значение» и обеспечивающая быстрый доступ по ключу. Работа основана на трёх принципах:  
1. Хеширование — ключ преобразуется в целое число с помощью хеш‑функции.  
2. Индексация — хеш используется для выбора позиции в массиве.  
3. Разрешение коллизий — в случае совпадений применяются методы цепочек или открытой адресации.  

В Python хеш‑таблицы реализуют двумя способами:  
1. Через класс, где список выступает как таблица, а хеш‑функция вычисляет индекс, например, на основе ASCII‑кода первого символа ключа. Методы: `set()`, `get()`, `remove()`.  
2. В виде массива бакетов фиксированного размера. Каждый бакет хранит ключ, значение и хеш. Возможные способы разрешения коллизий:  
   - простая перезапись;  
   - использование цепочек (`LinkedList`);  
   - открытая адресация (линейное пробирование);  
   - двойное хеширование.  

В C++ используются контейнеры стандартной библиотеки, например `std::unordered_map`, который реализует хеш‑таблицу с цепочечным хешированием. Есть и возможность ручной реализации через массив связанных списков. Основные методы: `table[key] = value`, `find(key)`, `erase(key)`, `clear()`.  
В Java для хеш‑таблиц применяются классы `Hashtable` и `HashMap`. `HashMap` реализует интерфейс `Map` и хранит элементы в виде пар «ключ‑значение» в массиве списков. Основные методы: `put()`, `get()`, `getOrDefault()`, `containsKey()`, `remove()`, `putAll()`.

